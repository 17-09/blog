---
layout: post
title: Don't invent your own resource manage routine
lang: en
ref: RAII
date: 2016-10-26T14:10:00+0800
categories: cpp resource
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Recently, I have encountered a legacy code base at working. There are several tremendous class written like this:
</p>
<div class="org-src-container">

<pre class="src src-c++">class ExtnlOutData
{
public:
    int phase;
    int* phaseIdx;
    char** phaseNames;
    ...

    ExtnlDLLData() : phaseIdx(NULL), phaseNames(NULL) {}

    ~ExtnlDLLData()
    {
	if (phaseIdx) {
	    delete[] phaseIdx;
	    phaseIdx = NULL;
	}

	if (phaseNames) {
	    for (int i = 0; i != phase; ++i) {
		if (phaseNames[i]) delete[] phaseNames[i];
	    delete[] phaseNames;
	    phaseNames = NULL;
	}
    }
}
</pre>
</div>

<p>
The real class is much bigger. We can critize this snippet in many different way. For example, the copy-operations will do shallow copy, which is counter-intuitive. And programmers of the dynamic libraries conform this interface need to allocate memory themselves, which is monotonous and error-prone. If we allocate more space to <code>phaseIdx</code> than <code>sizeof(int) * phase</code>, memory leak happens; if we allocate less space, the program will crash mysteriously. 
</p>

<p>
I want to focus on the "DLL" part today. This class is designed as an interface of customized plug-ins for our software. It was used like this:
</p>
<div class="org-src-container">

<pre class="src src-c++">void calculate ()
{
    ExtnlOutData data;
    extnlDllCalculate(&amp;data);

    // Do something about data
}
</pre>
</div>

<p>
The problem is that now all parts of our software need to be compiled by the same compiler which build legacy dlls (In our case, it is Visual Studio 2008, which is quiet ancient). The reason is that we destory memory outside the dll while we allocate memory outside the dynamic libraries. Since different compilers may call different memory management functions, the program will crash at the destructor of <code>data</code>. This situation is just like what happen when we combine <code>malloc()</code> and <code>delete</code>, but it is a lot more insidious.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> More example</h2>
<div class="outline-text-2" id="text-2">
<p>
It is suprised to mt that some otherwise well designed code base suffer similar problem. For instance, the <i>Qt Library</i>'s parent child relationship is essentially a similar resource manage strategy. If you have used QT, you must have written code like this:
</p>
<div class="org-src-container">

<pre class="src src-c++">void foo(QString name, QFont font)
{
    // Not real OT code
    QTabWidget parent;
    auto child = new QWidget;
    parent.addTab(child);
    child.setName(name);
    child.setFont(font);
} // The distructor of parent will destory child
</pre>
</div>
<p>
As a consequence, Qt, unlike most libraries, cannot be linked by different compilers than what itself compiled. For example, QT 5.7.0 for windows 64 binaries have three versions (VS 2015, VS 2013, MinGW). We must use corresponding compilers to develop QT application.
</p>

<p>
If you are programmers develop software solely for POSIX platforms, you may think it is not your bussiness. But I have another point relate to you, too. The point is, those customized resource manage strategies are innately exception-unsafe. Consider what will happen if <code>setName</code> or <code>setFont</code> can throw exceptions. An innocuous order change by clients will introduce leak:
</p>
<div class="org-src-container">

<pre class="src src-c++">child.setName(name);
child.setFont(font);
// if the above lines throw, the child will never be freed
parent.addTab(child);
</pre>
</div>
<p>
No wonder old style libraries like QT forbid exceptions for "historical reasons". But the library authors still cannot prohibit clients do something like this:
</p>
<div class="org-src-container">

<pre class="src src-c++">child.setName(name);
child.setFont(font);
if (!child.valid()) throw Exception{"Invalid tab"}; // May cause leak
parent.addTab(child);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> RAII to rescue</h2>
<div class="outline-text-2" id="text-3">
<p>
In the title, I discourage you from inventing your own resource manage routine. The reason is c++ already have a standard resource manage idiom <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>. It can easily eradicate problems about leak and unmatched system functions memtioned above. The first example can easily be redesigned to this:
</p>
<div class="org-src-container">

<pre class="src src-c++">struct PhaseData
{
    int ID;
    std::string name;
}

class ExternalOutData
{
public:
    ...

private:
    std::vector&lt;PhaseData&gt; data;
    ...
}
</pre>
</div>

<p>
As for the gui example, if you decide to write a new GUI library now, you can design your interface to be used like this:
</p>
<div class="org-src-container">

<pre class="src src-c++">void foo(MyString name, MyFont font)
{
    MyTabWidget parent;
    auto child = std::make_unique(MyWidget);
    child.setName(name);
    child.setFont(font);
    parent.addTab(std::move(child));
} // The distructor of parent will destory child
</pre>
</div>
<p>
This version is a bit more verbose, but it has the similar usage of QT, and none of QT's problems.</p>
</div>
</div>
